<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on Matthew Alp</title><link>https://mattalp.com/blog/</link><description>Recent content in Blogs on Matthew Alp</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 21 Jul 2022 10:53:09 -0400</lastBuildDate><atom:link href="https://mattalp.com/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>On Dispatch Chains</title><link>https://mattalp.com/blog/dispatch-chains/</link><pubDate>Thu, 21 Jul 2022 10:53:09 -0400</pubDate><guid>https://mattalp.com/blog/dispatch-chains/</guid><description>Intro In Ruby, practically everything is an object- an instance of a class containing some data, interacting through sending or receiving messages (via method calls). Unlike statically typed languages, wherein one knows at compile time what the set of messages an object can respond to (i.e. what methods are defined on a class), Ruby provides an extensive suite of ways of extending and modifying this set at run time.
As a consequence of this paradigm, Ruby must look up the method instructions you wish to invoke every time that you request to call a method by name, which is a costly operation involving traversing the objectâ€™s ancestry to ascertain if and where the method itself can be executed from.</description></item></channel></rss>