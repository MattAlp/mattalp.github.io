<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Matthew Alp</title><link>https://MattAlp.github.io/</link><description>Matthew Alp</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 21 Jul 2022 10:53:09 -0400</lastBuildDate><atom:link href="https://MattAlp.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>On Dispatch Chains</title><link>https://MattAlp.github.io/posts/dispatch-chains/</link><pubDate>Thu, 21 Jul 2022 10:53:09 -0400</pubDate><guid>https://MattAlp.github.io/posts/dispatch-chains/</guid><description>&lt;h2 id="intro" >Intro
&lt;span>
&lt;a href="#intro">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>In Ruby, practically everything is an object- an instance of a class containing some data, interacting through sending or receiving messages (via method calls). Unlike statically typed languages, wherein one knows at compile time what the set of messages an object can respond to (i.e. what methods are defined on a class), Ruby provides an extensive suite of ways of extending and modifying this set at run time.&lt;/p>
&lt;p>As a consequence of this paradigm, Ruby must look up the method instructions you wish to invoke every time that you request to call a method by name, which is a costly operation involving traversing the object’s ancestry to ascertain if and where the method itself can be executed from. In the interest of performance, this process is sped up by caching the results of these lookups and removing the need for redundant work.&lt;/p>
&lt;p>In most implementations of Ruby, this is done via inline caching. Historically, this is done in CRuby/MRI through the use of a “global method state (number)” and a “class serial number”. As shown in Aaron Patterson&amp;rsquo;s &lt;a href="https://tenderlovemaking.com/2015/12/23/inline-caching-in-mri.html">article on in inline caching in MRI&lt;/a>, the global method state is a global serial number that gets incremented whenever class definitions are mutated. The class serial number is a number derived from the class of whichever object is receiving a method call at a specific call site. This can be illustrated by running the following Ruby code (before Ruby 3+, as things work a little differently there):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">p &lt;span style="color:#66d9ef">RubyVM&lt;/span>&lt;span style="color:#f92672">.&lt;/span>stat
&lt;span style="color:#66d9ef">module&lt;/span> Kernel
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">monkey_patched_method&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
p &lt;span style="color:#66d9ef">RubyVM&lt;/span>&lt;span style="color:#f92672">.&lt;/span>stat
&lt;span style="color:#75715e"># Notice that global_method_state is incremented at this point&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
p &lt;span style="color:#66d9ef">RubyVM&lt;/span>&lt;span style="color:#f92672">.&lt;/span>stat
&lt;span style="color:#75715e"># Class serial will have increased once by now&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
p &lt;span style="color:#66d9ef">RubyVM&lt;/span>&lt;span style="color:#f92672">.&lt;/span>stat
&lt;span style="color:#75715e"># Class serial will have increased twice by now&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We should see something like&lt;/p>
&lt;pre tabindex="0">&lt;code>{:global_method_state=&amp;gt;133, :global_constant_state=&amp;gt;904, :class_serial=&amp;gt;6329}
{:global_method_state=&amp;gt;134, :global_constant_state=&amp;gt;904, :class_serial=&amp;gt;6329}
{:global_method_state=&amp;gt;134, :global_constant_state=&amp;gt;905, :class_serial=&amp;gt;6331}
{:global_method_state=&amp;gt;134, :global_constant_state=&amp;gt;906, :class_serial=&amp;gt;6333}
&lt;/code>&lt;/pre>&lt;p>Furthermore, Aaron points out that in CRuby (&amp;lt;3.1) the cache is rather limited, storing exactly one key-value pair per &lt;em>call site&lt;/em> (code invocation location), and then proceeds to present several situations which are failed by the existing caching mechanism. We see that even when a change to a class is small and localized, the change to global method state and class serials could blow out unrelated caches and slow down performance.&lt;/p>
&lt;h2 id="polymorphic-inline-caches--dispatch-chains" >Polymorphic Inline Caches &amp;amp; Dispatch Chains
&lt;span>
&lt;a href="#polymorphic-inline-caches--dispatch-chains">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>This is where &lt;a href="https://en.wikipedia.org/wiki/Inline_caching">(polymorphic) inline caches&lt;/a> and &lt;a href="https://chrisseaton.com/truffleruby/pldi15-metaprogramming/pldi15-marr-et-al-zero-overhead-metaprogramming.pdf">dispatch chaining&lt;/a> come in.&lt;/p>
&lt;p>Let&amp;rsquo;s start with an inline cache; a small cache included &lt;em>inline&lt;/em> (traditionally alongside a call site for a method) that removes the need for redundant method lookup work.&lt;/p>
&lt;video preload="auto" width="100%" autoplay loop muted playsinline class="html-video">
&lt;source src="https://MattAlp.github.io/posts/dispatch-chains/Inline-Cache.mp4" type="video/mp4">
&lt;span>Your browser doesn't support embedded videos, but don't worry, you can &lt;a href="https://MattAlp.github.io/posts/dispatch-chains/Inline-Cache.mp4">download it&lt;/a> and watch it with your favorite video player!&lt;/span>
&lt;/video>
&lt;p>The cache described above could be described as monomorphic; it fares best when dealing with call sites that only see one (mono) type used, rather than some small number n &amp;gt; 1 (a polymorphic site) or such a large number of variations that it wouldn&amp;rsquo;t be reasonable to cache and look up entries (a megamorphic site).&lt;/p>
&lt;p>A polymorphic inline cache expands on this by supporting matching on multiple keys (where key is a like a class or name, or &lt;em>generalized&lt;/em> to a set of properties such as class &lt;em>and&lt;/em> name) to yield multiple call sites.&lt;/p>
&lt;video preload="auto" width="100%" autoplay loop muted playsinline class="html-video">
&lt;source src="https://MattAlp.github.io/posts/dispatch-chains/Poly-Inline-Cache.mp4" type="video/mp4">
&lt;span>Your browser doesn't support embedded videos, but don't worry, you can &lt;a href="https://MattAlp.github.io/posts/dispatch-chains/Poly-Inline-Cache.mp4">download it&lt;/a> and watch it with your favorite video player!&lt;/span>
&lt;/video>
&lt;p>A dispatch chain further expands this model of caching &amp;amp; guarding on complex operations by constructing a tree of polymorphic inline caches so that advanced dispatch decisions can be made, in order to support Ruby&amp;rsquo;s complex object model and expressive metaprogramming system. For example, a &lt;code>send&lt;/code> can have a tree that first dispatches on&lt;/p>
&lt;ul>
&lt;li>the method name,&lt;/li>
&lt;li>then on the class,&lt;/li>
&lt;li>then on the bytecode or machine code that represents the returned method, in order to execute code.&lt;/li>
&lt;/ul>
&lt;video preload="auto" width="100%" autoplay loop muted playsinline class="html-video">
&lt;source src="https://MattAlp.github.io/posts/dispatch-chains/Dispatch-Chain-Sideways-tree.mp4" type="video/mp4">
&lt;span>Your browser doesn't support embedded videos, but don't worry, you can &lt;a href="https://MattAlp.github.io/posts/dispatch-chains/Dispatch-Chain-Sideways-tree.mp4">download it&lt;/a> and watch it with your favorite video player!&lt;/span>
&lt;/video>
&lt;p>However, a notable downside of said tree model is that memory use from constructing caches can quickly expand as the tree gets wider and wider at subsequent levels of branching decisions.&lt;/p>
&lt;p>TruffleRuby further develops on this idea by constructing a series of decision trees, with the output of each (polymorphic cache) going as input to the next. This means that if one decision tree produces the same value from multiple branches, the next decision tree sees them as the same value, instead of having a new copy of the tree (and all potential decisions cascading from that point) for the repeated values.&lt;/p>
&lt;p>&amp;hellip;&lt;/p>
&lt;video preload="auto" width="100%" autoplay loop muted playsinline class="html-video">
&lt;source src="https://MattAlp.github.io/posts/dispatch-chains/Dispatch-Chain-Sideways-tree-with-duplicates.mp4" type="video/mp4">
&lt;span>Your browser doesn't support embedded videos, but don't worry, you can &lt;a href="https://MattAlp.github.io/posts/dispatch-chains/Dispatch-Chain-Sideways-tree-with-duplicates.mp4">download it&lt;/a> and watch it with your favorite video player!&lt;/span>
&lt;/video>
&lt;p>This is particularly useful because it means that we aren&amp;rsquo;t as afraid to add more levels of decision trees and granular caches as memory use isn&amp;rsquo;t expected to increase exponentially. As a result, rather than having one PIC responsible for the caching of a complex process (such as method invocation), a dispatch chain is made up of several PICs with separate concerns and unique cache keys. This both improves the likelihood of breaking down a previously mega/poly site to a poly/mono site and mitigates the consequences of having a megamorphic site&amp;rsquo;s cache blowout cascade through the entire chain of operations being performed.&lt;/p>
&lt;p>Let&amp;rsquo;s explore how the use of dispatch chains speeds up method invocation in TruffleRuby, a high-speed JIT-compiled Ruby on top of the GraalVM and the Truffle DSL.&lt;/p>
&lt;h2 id="trufflerubys-method-invocation-mechanism" >TruffleRuby’s Method Invocation Mechanism
&lt;span>
&lt;a href="#trufflerubys-method-invocation-mechanism">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;blockquote>
&lt;p>First, a quick disclaimer; TruffleRuby makes heavy use of indirection and abstraction within its codebase, which can detract from the exploratory process and overwhelm readers. I’ve simplified and hand-waved away details that aren’t pertinent, but have linked to the source code for the curious.&lt;/p>
&lt;/blockquote>
&lt;p>Let&amp;rsquo;s kick off the method invocation pipeline via&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#75715e"># Object o&lt;/span>
o&lt;span style="color:#f92672">.&lt;/span>send &lt;span style="color:#e6db74">:foo_method&lt;/span>
o&lt;span style="color:#f92672">.&lt;/span>foo_method
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will kick off the method invocation process via a &lt;a href="https://github.com/oracle/truffleruby/blob/e2f62b89b80cf1d9334dca4d31ef8e379a8712c5/src/main/java/org/truffleruby/core/basicobject/BasicObjectNodes.java#L584-L595">SendNode&lt;/a>, which defers to several other nodes for supporting functionality. Like all Truffle DSL languages, TruffleRuby uses nodes and an AST for its intermediate representation.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Within the send node, we defer to an instantiated-and-stored &lt;a href="https://github.com/oracle/truffleruby/blob/f9ab0cf8b658bdb6b8a68880556c0b072a2e11a1/src/main/java/org/truffleruby/language/dispatch/DispatchNode.java">DispatchNode&lt;/a> responsible for handling lookup and subsequent execution from a call site effectively.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#a6e22e">DispatchNode&lt;/span>&lt;span style="color:#f92672">(&lt;/span>
MetaClassNode metaclassNode&lt;span style="color:#f92672">,&lt;/span>
LookupMethodNode methodLookup&lt;span style="color:#f92672">,&lt;/span>
CallInternalMethodNode callNode&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">metaclassNode&lt;/span> &lt;span style="color:#f92672">=&lt;/span> metaclassNode&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">methodLookup&lt;/span> &lt;span style="color:#f92672">=&lt;/span> methodLookup&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">callNode&lt;/span> &lt;span style="color:#f92672">=&lt;/span> callNode&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Among other things, the dispatch node contains a &lt;a href="https://github.com/oracle/truffleruby/blob/75d3da3737ff43c906086aaaf349b09360b10bda/src/main/java/org/truffleruby/language/methods/LookupMethodNode.java">LookupMethodNode&lt;/a> and &lt;a href="https://github.com/oracle/truffleruby/blob/83e0079d6f9edc96a252a59d794cd1b6af8d7ca3/src/main/java/org/truffleruby/language/methods/CallInternalMethodNode.java">CallInternalMethodNode&lt;/a>, separating the mechanisms responsible for retrieving a method on a class and calling it, respectively.&lt;/p>
&lt;p>Here is what this part of the AST &amp;ldquo;looks&amp;rdquo; like:
&lt;img src="NodeHierarchy.svg" alt="">&lt;/p>
&lt;p>Let’s explore &lt;code>LookupMethodNode&lt;/code> first:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LookupMethodNode&lt;/span>
cache &lt;span style="color:#e6db74">:meta_class&lt;/span>, &lt;span style="color:#e6db74">:name&lt;/span>
cache &lt;span style="color:#e6db74">&amp;#34;lookup_method(cached_meta_class, cached_name)&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">as&lt;/span>: &lt;span style="color:#e6db74">:method_lookup_result&lt;/span>
limit &lt;span style="color:#e6db74">:get_cache_limit&lt;/span>
guard_on &lt;span style="color:#e6db74">:cached_meta_class&lt;/span>, &lt;span style="color:#e6db74">:cached_name&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">lookup_method_cached&lt;/span>(meta_class, name)
&lt;span style="color:#66d9ef">return&lt;/span> method_lookup_result
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Simplified from:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@Specialization&lt;/span>&lt;span style="color:#f92672">(&lt;/span>
guards &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;isSingleContext()&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;metaClass == cachedMetaClass&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;name == cachedName&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;config == cachedConfig&amp;#34;&lt;/span> &lt;span style="color:#f92672">},&lt;/span>
assumptions &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;methodLookupResult.getAssumptions()&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span>
limit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;getCacheLimit()&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">protected&lt;/span> InternalMethod &lt;span style="color:#a6e22e">lookupMethodCached&lt;/span>&lt;span style="color:#f92672">(&lt;/span>
Frame frame&lt;span style="color:#f92672">,&lt;/span> RubyClass metaClass&lt;span style="color:#f92672">,&lt;/span> String name&lt;span style="color:#f92672">,&lt;/span> DispatchConfiguration config&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#a6e22e">@Cached&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;metaClass&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> RubyClass cachedMetaClass&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#a6e22e">@Cached&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> String cachedName&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#a6e22e">@Cached&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;config&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> DispatchConfiguration cachedConfig&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#a6e22e">@Cached&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;lookupCached(getContext(), frame, cachedMetaClass, cachedName, config)&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> MethodLookupResult methodLookupResult&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> methodLookupResult&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getMethod&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We&amp;rsquo;ve encountered our first generalized PIC in the dispatch chain! Caching on the &lt;code>metaClass&lt;/code> (essentially the class of the object) and the &lt;code>name&lt;/code> of the method being passed in, this node takes a Ruby class and method name to look up, and pops out an &lt;code>InternalMethod&lt;/code> object. Note that this stores up to &lt;code>getCacheLimit()&lt;/code> entries, which is why it is a &lt;em>poly&lt;/em> morphic cache.&lt;/p>
&lt;p>Next, let&amp;rsquo;s examine &lt;code>CallInternalMethodNode&lt;/code>, which is passed the lookup node’s &lt;code>InternalMethod&lt;/code> result:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">final&lt;/span> InternalMethod method &lt;span style="color:#f92672">=&lt;/span> lookupMethodNode&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">execute&lt;/span>&lt;span style="color:#f92672">(&lt;/span>frame&lt;span style="color:#f92672">,&lt;/span> metaclass&lt;span style="color:#f92672">,&lt;/span> methodName&lt;span style="color:#f92672">,&lt;/span> config&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * Cut out implementationdetails
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> callNode&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">execute&lt;/span>&lt;span style="color:#f92672">(&lt;/span>frame&lt;span style="color:#f92672">,&lt;/span> method&lt;span style="color:#f92672">,&lt;/span> receiver&lt;span style="color:#f92672">,&lt;/span> rubyArgs&lt;span style="color:#f92672">,&lt;/span> literalCallNode&lt;span style="color:#f92672">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Simplified once again:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CallInternalMethodNode&lt;/span>
cache &lt;span style="color:#e6db74">:method&lt;/span>
cache &lt;span style="color:#e6db74">&amp;#34;method.get_call_target&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">as&lt;/span>: &lt;span style="color:#e6db74">:call_target&lt;/span>
cache &lt;span style="color:#e6db74">&amp;#34;create_call(cached_method.get_name, cached_call_target)&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">as&lt;/span>: &lt;span style="color:#e6db74">:call_node&lt;/span>
guard_on &lt;span style="color:#e6db74">:cached_call_target&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;!cached_method.always_inlined?&amp;#34;&lt;/span>
limit &lt;span style="color:#e6db74">:get_cache_limit&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">call_cached&lt;/span>(method, &lt;span style="color:#f92672">*&lt;/span>method_args)
&lt;span style="color:#75715e"># Note how the call node is generated and cached as part of the cache entry from a cached method and cached call target.&lt;/span>
&lt;span style="color:#75715e"># As long as the guards are not violated, all of this is stored in the poly cache and invoked speedily.&lt;/span>
call_node&lt;span style="color:#f92672">.&lt;/span>call(call_target, method_args)
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>From:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@Specialization&lt;/span>&lt;span style="color:#f92672">(&lt;/span>
guards &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;isSingleContext()&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;method.getCallTarget() == cachedCallTarget&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;!cachedMethod.alwaysInlined()&amp;#34;&lt;/span> &lt;span style="color:#f92672">},&lt;/span>
assumptions &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;getMethodAssumption(cachedMethod)&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#75715e">// to remove the inline cache entry when the method is redefined or removed
&lt;/span>&lt;span style="color:#75715e">&lt;/span> limit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;getCacheLimit()&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">protected&lt;/span> Object &lt;span style="color:#a6e22e">callCached&lt;/span>&lt;span style="color:#f92672">(&lt;/span>
InternalMethod method&lt;span style="color:#f92672">,&lt;/span> Object receiver&lt;span style="color:#f92672">,&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> rubyArgs&lt;span style="color:#f92672">,&lt;/span> LiteralCallNode literalCallNode&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#a6e22e">@Cached&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;method.getCallTarget()&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> RootCallTarget cachedCallTarget&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#a6e22e">@Cached&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;method&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> InternalMethod cachedMethod&lt;span style="color:#f92672">,&lt;/span>
&lt;span style="color:#a6e22e">@Cached&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;createCall(cachedMethod.getName(), cachedCallTarget)&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> DirectCallNode callNode&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>literalCallNode &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
literalCallNode&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">copyRuby2KeywordsHash&lt;/span>&lt;span style="color:#f92672">(&lt;/span>rubyArgs&lt;span style="color:#f92672">,&lt;/span> cachedMethod&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getSharedMethodInfo&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> callNode&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">call&lt;/span>&lt;span style="color:#f92672">(&lt;/span>RubyArguments&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">repackForCall&lt;/span>&lt;span style="color:#f92672">(&lt;/span>rubyArgs&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As a result, we&amp;rsquo;re able to sequence these PICs so that the processes of converting a call site to a method lookup and the method execution are cached separately &amp;amp; based on unique properties relevant to the data flow at each process.&lt;/p>
&lt;h2 id="what-can-we-take-away-from-it-all" >What can we take away from it all?
&lt;span>
&lt;a href="#what-can-we-take-away-from-it-all">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>TruffleRuby uses this advanced and complex/compound design of inline caching because it tackles some of the dynamic nature of Ruby. For example, complex class hierarchies methods that are aliased with different names can result in a call to the same code, and our technique means we can de-duplicate that call and ensure speedy execution of interpreted &lt;em>and&lt;/em> JITted code.&lt;/p>
&lt;p>Currently, we&amp;rsquo;re using these techniques to optimise conventional Ruby and especially metaprogramming in powerful ways. We think we can use their power and flexibility to address other Ruby idioms that aren&amp;rsquo;t currently well-optimised, such as extensive use of singletons to define per-object methods. At the moment these trip up the VM as they cause the first layer of caching to become megamorphic. Our ongoing and future work is look at adding another level of indirection and further specializing on top of the dispatch system to accomodate for singleton classes, ensuring that idiomatic &amp;amp; expressive Ruby continues to be performant.&lt;/p>
&lt;h2 id="special-thanks" >Special Thanks
&lt;span>
&lt;a href="#special-thanks">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Thanks to &lt;a href="https://chrisseaton.com/">Chris Seaton&lt;/a>, &lt;a href="https://nirvdrum.com/">Kevin Menard&lt;/a>, &lt;a href="https://kddnewton.com/">Kevin Newton&lt;/a>, and &lt;a href="https://twitter.com/Kaan0zkan">Kaan Ozkan&lt;/a> for looking over and providing feedback on early drafts of mine, and to &lt;a href="https://tenderlovemaking.com/">Aaron Patterson&lt;/a> for the MRI caching crash course.&lt;/p></description></item><item><title>About</title><link>https://MattAlp.github.io/about/</link><pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate><guid>https://MattAlp.github.io/about/</guid><description>&lt;p>20 year old CS student writes about his struggles with fizzbuzz. &lt;a href="https://twitter.com/MatthewAlp">@MatthewAlp&lt;/a> on Twitter, &lt;a href="https://github.com/MattAlp">@MattAlp&lt;/a> on GitHub.&lt;/p></description></item></channel></rss>